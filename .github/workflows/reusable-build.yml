name: Reusable Build & Test Workflow

on:
  workflow_call:
    inputs:
      release-build:
        description: 'Whether to build in release mode'
        required: false
        type: boolean
        default: false
      enable-cache:
        description: 'Whether to enable caching of external binaries'
        required: false
        type: boolean
        default: false
      package-artifacts:
        description: 'Whether to package release artifacts'
        required: false
        type: boolean
        default: false
      upload-to-release:
        description: 'Whether to upload artifacts to GitHub release'
        required: false
        type: boolean
        default: false

jobs:
  build:
    name: Build and test infc
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-14]
        toolchain:
          - nightly
    runs-on: ${{ matrix.os }}
    steps:
      - name: Setup Rust
        uses: actions/checkout@v4.1.3
      
      - name: Cache external binaries
        if: inputs.enable-cache
        uses: actions/cache@v4
        id: cache-binaries
        with:
          path: external/
          key: ${{ runner.os }}-binaries-v6
          restore-keys: |
            ${{ runner.os }}-binaries-
      
      - name: Download binaries (Linux)
        if: runner.os == 'Linux' && (!inputs.enable-cache || steps.cache-binaries.outputs.cache-hit != 'true')
        run: |
          mkdir -p external/bin/linux external/lib/linux
          # Download and extract inf-llc
          curl -L "https://storage.googleapis.com/external_binaries/linux/bin/inf-llc.zip" -o /tmp/inf-llc.zip
          unzip -o /tmp/inf-llc.zip -d external/bin/linux/
          # Download and extract rust-lld
          curl -L "https://storage.googleapis.com/external_binaries/linux/bin/rust-lld.zip" -o /tmp/rust-lld.zip
          unzip -o /tmp/rust-lld.zip -d external/bin/linux/
          # Download and extract libLLVM
          curl -L "https://storage.googleapis.com/external_binaries/linux/lib/libLLVM.so.21.1-rust-1.94.0-nightly.zip" -o /tmp/libLLVM.zip
          unzip -o /tmp/libLLVM.zip -d external/lib/linux/
          # Make executables
          chmod +x external/bin/linux/inf-llc external/bin/linux/rust-lld
      
      - name: Download binaries (macOS)
        if: runner.os == 'macOS' && (!inputs.enable-cache || steps.cache-binaries.outputs.cache-hit != 'true')
        run: |
          mkdir -p external/bin/macos
          # Download and extract inf-llc
          curl -L "https://storage.googleapis.com/external_binaries/macos/bin/inf-llc.zip" -o /tmp/inf-llc.zip
          unzip -o /tmp/inf-llc.zip -d external/bin/macos/
          # Download and extract rust-lld
          curl -L "https://storage.googleapis.com/external_binaries/macos/bin/rust-lld.zip" -o /tmp/rust-lld.zip
          unzip -o /tmp/rust-lld.zip -d external/bin/macos/
          # Make executables
          chmod +x external/bin/macos/inf-llc external/bin/macos/rust-lld
      
      - name: Download binaries (Windows)
        if: runner.os == 'Windows' && (!inputs.enable-cache || steps.cache-binaries.outputs.cache-hit != 'true')
        run: |
          New-Item -ItemType Directory -Force -Path external\bin\windows
          New-Item -ItemType Directory -Force -Path external\llvm\windows
          New-Item -ItemType Directory -Force -Path external\lib\windows
          
          # Download and extract inf-llc.exe
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/bin/inf-llc.zip" -OutFile "$env:TEMP\inf-llc.zip"
          Expand-Archive -Path "$env:TEMP\inf-llc.zip" -DestinationPath external\bin\windows\ -Force
          
          # Download and extract rust-lld.exe
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/bin/rust-lld.zip" -OutFile "$env:TEMP\rust-lld.zip"
          Expand-Archive -Path "$env:TEMP\rust-lld.zip" -DestinationPath external\bin\windows\ -Force
          
          # Download complete LLVM 21.1.1 (MSYS2 build with all targets)
          Write-Output "Downloading complete LLVM 21.1.1 from GCS..."
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/llvm/llvm-21-msys2-ucrt64-full-targets.zip" -OutFile "$env:TEMP\llvm-full.zip"
          Write-Output "Extracting LLVM to external\llvm\windows..."
          Expand-Archive -Path "$env:TEMP\llvm-full.zip" -DestinationPath external\llvm\windows\ -Force
          
          # Download XML-related import/static libraries
          Write-Output "Downloading XML import libs..."
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/build/libxml2.dll.a" -OutFile "external\lib\windows\libxml2.dll.a"
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/build/libxml2.a" -OutFile "external\lib\windows\libxml2.a"
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/build/libiconv.dll.a" -OutFile "external\lib\windows\libiconv.dll.a"
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/build/libz.a" -OutFile "external\lib\windows\libz.a"
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/build/libzstd.dll.a" -OutFile "external\lib\windows\libzstd.dll.a"
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/build/libffi.dll.a" -OutFile "external\lib\windows\libffi.dll.a"
          
          # Download runtime DLLs
          Write-Output "Downloading XML runtime DLLs..."
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/build/libxml2-16.dll" -OutFile "external\bin\libxml2-16.dll"
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/build/libiconv-2.dll" -OutFile "external\bin\libiconv-2.dll"
          Invoke-WebRequest -Uri "https://storage.googleapis.com/external_binaries/windows/build/zlib1.dll" -OutFile "external\bin\zlib1.dll"
          
          # Copy LLVM DLL to external\bin for runtime
          Copy-Item "external\llvm\windows\bin\libLLVM-21.dll" "external\bin\libLLVM-21.dll" -Force
          
          Write-Output "All Windows binaries downloaded and cached"
      
      - name: Update Rust
        run: |
          rustup update ${{ matrix.toolchain }}
          rustup default ${{ matrix.toolchain }}
          rustup component add llvm-tools-preview
      
      - name: Add MinGW target (Windows)
        if: runner.os == 'Windows'
        run: |
          rustup target add x86_64-pc-windows-gnu
          rustup default ${{ matrix.toolchain }}-x86_64-pc-windows-gnu
      
      - name: Install MSYS2 (Windows)
        if: runner.os == 'Windows'
        uses: msys2/setup-msys2@v2
        with:
          msystem: UCRT64
          location: C:\msys64
          update: true
          install: mingw-w64-ucrt-x86_64-toolchain
          path-type: strict

      - name: Configure MinGW PATH (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Add MSYS2 UCRT64 to PATH via GITHUB_PATH (prepends, takes effect in subsequent steps)
          Add-Content -Path $env:GITHUB_PATH -Value "C:\msys64\ucrt64\bin"

          # Remove conflicting MinGW installations and update current process PATH
          $filteredPath = ($env:PATH -split ';' | Where-Object {
            $_ -notmatch 'C:\\mingw64' -and $_ -notmatch 'Strawberry'
          }) -join ';'
          $env:PATH = "C:\msys64\ucrt64\bin;$filteredPath"

          # Debug: show MSYS2 directory contents
          Write-Output "MSYS2 UCRT64 bin directory contents:"
          Get-ChildItem "C:\msys64\ucrt64\bin" -Filter "dlltool*" -ErrorAction SilentlyContinue | Select-Object Name
          Get-ChildItem "C:\msys64\ucrt64\bin" -Filter "*gcc*" -ErrorAction SilentlyContinue | Select-Object Name

          # Verify dlltool is accessible
          Write-Output "Verifying MinGW tools..."
          Get-Command dlltool -ErrorAction Stop | Select-Object -ExpandProperty Source
          Get-Command x86_64-w64-mingw32-gcc -ErrorAction Stop | Select-Object -ExpandProperty Source
      
      - name: Install LLVM (Linux)
        if: runner.os == 'Linux'
        run: |
          wget https://apt.llvm.org/llvm.sh
          chmod +x llvm.sh
          sudo ./llvm.sh 21
          sudo apt-get install -y llvm-21-dev libpolly-21-dev
      
      - name: Install LLVM (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install llvm@21 || brew install llvm
      
      - name: Setup LLVM (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $llvmDir = "$PWD\external\llvm\windows"
          $llvmBin = Join-Path $llvmDir "bin"
          $dstLib = Join-Path $llvmDir "lib"
          $cachedLibDir = "external\lib\windows"

          # Copy libraries into LLVM lib directory
          Copy-Item (Join-Path $cachedLibDir "libxml2.dll.a") (Join-Path $dstLib "libxml2s.lib") -Force
          Copy-Item (Join-Path $cachedLibDir "libxml2.dll.a") (Join-Path $dstLib "libxml2.dll.a") -Force
          Copy-Item (Join-Path $cachedLibDir "libxml2.a") (Join-Path $dstLib "libxml2.a") -Force
          Copy-Item (Join-Path $cachedLibDir "libiconv.dll.a") (Join-Path $dstLib "libiconv.dll.a") -Force
          Copy-Item (Join-Path $cachedLibDir "libz.a") (Join-Path $dstLib "libz.a") -Force
          Copy-Item (Join-Path $cachedLibDir "libzstd.dll.a") (Join-Path $dstLib "libzstd.dll.a") -Force
          Copy-Item (Join-Path $cachedLibDir "libffi.dll.a") (Join-Path $dstLib "libffi.dll.a") -Force

          # Add LLVM bin and external bin to PATH via GITHUB_PATH (prepends, takes effect in subsequent steps)
          Add-Content -Path $env:GITHUB_PATH -Value "$llvmBin"
          Add-Content -Path $env:GITHUB_PATH -Value "$PWD\external\bin"

          # Set environment variables (non-PATH)
          Add-Content -Path $env:GITHUB_ENV -Value "LLVM_SYS_211_PREFIX=$llvmDir"
          Add-Content -Path $env:GITHUB_ENV -Value "LIB=$dstLib;$env:LIB"
      
      - name: Set LLVM Prefix (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          echo "LLVM_SYS_211_PREFIX=/usr/lib/llvm-21" >> $GITHUB_ENV
      
      - name: Set LLVM Prefix (macOS)
        if: runner.os == 'macOS'
        run: |
          LLVM_PREFIX=$(brew --prefix llvm@21 2>/dev/null || brew --prefix llvm)
          echo "LLVM_SYS_211_PREFIX=$LLVM_PREFIX" >> $GITHUB_ENV
      
      - name: Install clippy nightly
        run: rustup component add clippy-preview
      
      - name: Build (Non-Windows)
        if: runner.os != 'Windows' && !inputs.release-build
        run: cargo build --verbose
      
      - name: Build (Windows MinGW)
        if: runner.os == 'Windows' && !inputs.release-build
        run: cargo build --verbose --target x86_64-pc-windows-gnu
      
      - name: Build Release (Non-Windows)
        if: runner.os != 'Windows' && inputs.release-build
        run: cargo build-full --release --verbose
      
      - name: Build Release (Windows MinGW)
        if: runner.os == 'Windows' && inputs.release-build
        run: cargo build-full --release --verbose --target x86_64-pc-windows-gnu
      
      - name: Verify vendored LLVM
        run: |
          file external/lib/linux/libLLVM.so.21.1-rust-1.94.0-nightly || true
          file target/debug/lib/libLLVM.so.21.1-rust-1.94.0-nightly || true
        if: runner.os == 'Linux' && !inputs.release-build
      
      - name: Verify vendored LLVM (Release)
        run: |
          file external/lib/linux/libLLVM.so.21.1-rust-1.94.0-nightly || true
          file target/release/lib/libLLVM.so.21.1-rust-1.94.0-nightly || true
        if: runner.os == 'Linux' && inputs.release-build
      
      - name: Test (Non-Windows)
        if: runner.os != 'Windows' && !inputs.release-build
        run: cargo test --verbose
      
      - name: Test (Windows MinGW)
        if: runner.os == 'Windows' && !inputs.release-build
        run: cargo test --verbose --target x86_64-pc-windows-gnu
      
      - name: Test Release (Non-Windows)
        if: runner.os != 'Windows' && inputs.release-build
        run: cargo test-full --verbose
      
      - name: Test Release (Windows MinGW)
        if: runner.os == 'Windows' && inputs.release-build
        run: cargo test-full --verbose --target x86_64-pc-windows-gnu
      
      - name: Clippy (Non-Windows)
        if: runner.os != 'Windows'
        run: cargo clippy --verbose -- -D warnings
      
      - name: Clippy (Windows MinGW)
        if: runner.os == 'Windows'
        run: cargo clippy --verbose --target x86_64-pc-windows-gnu -- -D warnings
      
      - name: Install Cargo audit
        run: cargo install cargo-audit
      
      - name: Audit
        run: cargo audit
      
      # Package artifacts (only for release builds)
      - name: Prepare infc Artifact Package (Windows)
        if: runner.os == 'Windows' && inputs.package-artifacts
        run: |
          New-Item -ItemType Directory -Force -Path artifact-infc\bin
          New-Item -ItemType Directory -Force -Path artifact-infc\lib
          Copy-Item target\x86_64-pc-windows-gnu\release\infc.exe artifact-infc\
          Copy-Item book\check_deps.ps1 artifact-infc\
          Copy-Item external\bin\windows\inf-llc.exe artifact-infc\bin\
          Copy-Item external\bin\windows\rust-lld.exe artifact-infc\bin\

      - name: Prepare infs Artifact Package (Windows)
        if: runner.os == 'Windows' && inputs.package-artifacts
        run: |
          New-Item -ItemType Directory -Force -Path artifact-infs\bin
          New-Item -ItemType Directory -Force -Path artifact-infs\lib
          Copy-Item target\x86_64-pc-windows-gnu\release\infs.exe artifact-infs\
          Copy-Item external\bin\windows\inf-llc.exe artifact-infs\bin\
          Copy-Item external\bin\windows\rust-lld.exe artifact-infs\bin\
      
      - name: Prepare infc Artifact Package (Linux)
        if: runner.os == 'Linux' && inputs.package-artifacts
        run: |
          mkdir -p artifact-infc/bin
          mkdir -p artifact-infc/lib
          cp target/release/infc artifact-infc/
          cp target/release/bin/* artifact-infc/bin/
          cp target/release/lib/* artifact-infc/lib/

      - name: Prepare infs Artifact Package (Linux)
        if: runner.os == 'Linux' && inputs.package-artifacts
        run: |
          mkdir -p artifact-infs/bin
          mkdir -p artifact-infs/lib
          cp target/release/infs artifact-infs/
          cp target/release/bin/* artifact-infs/bin/
          cp target/release/lib/* artifact-infs/lib/
      
      - name: Package infc Artifact (Windows)
        if: runner.os == 'Windows' && inputs.package-artifacts
        run: |
          7z a -tzip infc-windows-x64.zip .\artifact-infc\*
          certutil -hashfile infc-windows-x64.zip SHA256 > infc-windows-x64.zip.sha256

      - name: Package infs Artifact (Windows)
        if: runner.os == 'Windows' && inputs.package-artifacts
        run: |
          7z a -tzip infs-windows-x64.zip .\artifact-infs\*
          certutil -hashfile infs-windows-x64.zip SHA256 > infs-windows-x64.zip.sha256
      
      - name: Package infc Artifact (Linux)
        if: runner.os == 'Linux' && inputs.package-artifacts
        run: |
          tar -czf infc-linux-x64.tar.gz -C artifact-infc .
          sha256sum infc-linux-x64.tar.gz > infc-linux-x64.tar.gz.sha256

      - name: Package infs Artifact (Linux)
        if: runner.os == 'Linux' && inputs.package-artifacts
        run: |
          tar -czf infs-linux-x64.tar.gz -C artifact-infs .
          sha256sum infs-linux-x64.tar.gz > infs-linux-x64.tar.gz.sha256
      
      - name: Prepare infc Artifact Package (macOS)
        if: runner.os == 'macOS' && inputs.package-artifacts
        run: |
          mkdir -p artifact-infc/bin
          cp target/release/infc artifact-infc/
          cp target/release/bin/* artifact-infc/bin/ || true
          if [ -d target/release/lib ] && [ "$(ls -A target/release/lib)" ]; then
            mkdir -p artifact-infc/lib
            cp target/release/lib/* artifact-infc/lib/
          fi

      - name: Prepare infs Artifact Package (macOS)
        if: runner.os == 'macOS' && inputs.package-artifacts
        run: |
          mkdir -p artifact-infs/bin
          cp target/release/infs artifact-infs/
          cp target/release/bin/* artifact-infs/bin/ || true
          if [ -d target/release/lib ] && [ "$(ls -A target/release/lib)" ]; then
            mkdir -p artifact-infs/lib
            cp target/release/lib/* artifact-infs/lib/
          fi
      
      - name: Package infc Artifact (macOS)
        if: runner.os == 'macOS' && inputs.package-artifacts
        run: |
          tar -czf infc-macos-apple-silicon.tar.gz -C artifact-infc .
          shasum -a 256 infc-macos-apple-silicon.tar.gz > infc-macos-apple-silicon.tar.gz.sha256

      - name: Package infs Artifact (macOS)
        if: runner.os == 'macOS' && inputs.package-artifacts
        run: |
          tar -czf infs-macos-apple-silicon.tar.gz -C artifact-infs .
          shasum -a 256 infs-macos-apple-silicon.tar.gz > infs-macos-apple-silicon.tar.gz.sha256
      
      - name: Upload to Release (Windows)
        if: runner.os == 'Windows' && inputs.upload-to-release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            infc-windows-x64.zip
            infc-windows-x64.zip.sha256
            infs-windows-x64.zip
            infs-windows-x64.zip.sha256

      - name: Upload to Release (Linux)
        if: runner.os == 'Linux' && inputs.upload-to-release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            infc-linux-x64.tar.gz
            infc-linux-x64.tar.gz.sha256
            infs-linux-x64.tar.gz
            infs-linux-x64.tar.gz.sha256

      - name: Upload to Release (macOS)
        if: runner.os == 'macOS' && inputs.upload-to-release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            infc-macos-apple-silicon.tar.gz
            infc-macos-apple-silicon.tar.gz.sha256
            infs-macos-apple-silicon.tar.gz
            infs-macos-apple-silicon.tar.gz.sha256
      
      # Always upload workflow artifacts when packaging - needed for manifest generation
      - name: Upload Workflow Artifact infc (Windows)
        if: runner.os == 'Windows' && inputs.package-artifacts
        uses: actions/upload-artifact@v4
        with:
          name: infc-windows-x64
          path: |
            infc-windows-x64.*
          retention-days: 90
          compression-level: 0

      - name: Upload Workflow Artifact infs (Windows)
        if: runner.os == 'Windows' && inputs.package-artifacts
        uses: actions/upload-artifact@v4
        with:
          name: infs-windows-x64
          path: |
            infs-windows-x64.*
          retention-days: 90
          compression-level: 0

      - name: Upload Workflow Artifact infc (Linux)
        if: runner.os == 'Linux' && inputs.package-artifacts
        uses: actions/upload-artifact@v4
        with:
          name: infc-linux-x64
          path: |
            infc-linux-x64.*
          retention-days: 90
          compression-level: 0

      - name: Upload Workflow Artifact infs (Linux)
        if: runner.os == 'Linux' && inputs.package-artifacts
        uses: actions/upload-artifact@v4
        with:
          name: infs-linux-x64
          path: |
            infs-linux-x64.*
          retention-days: 90
          compression-level: 0

      - name: Upload Workflow Artifact infc (macOS)
        if: runner.os == 'macOS' && inputs.package-artifacts
        uses: actions/upload-artifact@v4
        with:
          name: infc-macos-apple-silicon
          path: |
            infc-macos-apple-silicon.*
          retention-days: 90
          compression-level: 0

      - name: Upload Workflow Artifact infs (macOS)
        if: runner.os == 'macOS' && inputs.package-artifacts
        uses: actions/upload-artifact@v4
        with:
          name: infs-macos-apple-silicon
          path: |
            infs-macos-apple-silicon.*
          retention-days: 90
          compression-level: 0

  # Generate release manifest after all platform builds complete
  #
  # PURPOSE:
  # This job generates a manifest.json file that is attached to each GitHub Release.
  # The manifest serves as a supplementary data source for:
  #
  # 1. Offline fallback - Tools can bundle or cache the manifest for environments
  #    without GitHub API access (air-gapped networks, CI/CD caching).
  #
  # 2. Third-party tooling - External package managers, installation scripts, and
  #    automation tools can consume the manifest without parsing HTML or using
  #    GitHub's rate-limited API.
  #
  # 3. Checksums - The manifest includes SHA256 checksums from .sha256 sidecar files,
  #    which the GitHub Releases API does not provide directly.
  #
  # NOTE: The infs runtime primarily fetches release information directly from the
  # GitHub Releases API
  # This manifest.json is supplementary and not required for normal operation.
  generate-manifest:
    name: Generate release manifest
    needs: build
    if: inputs.upload-to-release
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: false

      - name: Extract version from tag
        id: version
        run: |
          # Get tag from GITHUB_REF (refs/tags/v0.1.0 -> 0.1.0)
          TAG="${GITHUB_REF#refs/tags/}"
          VERSION="${TAG#v}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generating manifest for version $VERSION (tag: $TAG)"

      - name: Generate manifest.json
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          BASE_URL="https://github.com/${{ github.repository }}/releases/download/$TAG"

          # Start with empty array
          echo '[]' > manifest.json

          # Helper: add file entry (Go-style format)
          add_file() {
            local filename="$1" os="$2" arch="$3" tool="$4" sha_file="$5" archive="$6"

            [ -f "$sha_file" ] && [ -f "$archive" ] || return 0

            local sha=$(awk '{print $1}' "$sha_file" | grep -E '^[a-fA-F0-9]{64}$' | head -1)
            [ -n "$sha" ] || return 0

            local size=$(stat -c%s "$archive" 2>/dev/null || echo 0)

            jq --arg f "$filename" --arg o "$os" --arg a "$arch" --arg t "$tool" \
               --arg u "$BASE_URL/$filename" --arg s "$sha" --argjson sz "$size" \
               '. += [{filename:$f,os:$o,arch:$a,tool:$t,url:$u,sha256:$s,size:$sz}]' \
               manifest.json > tmp.json && mv tmp.json manifest.json
          }

          # Add all files
          add_file infc-linux-x64.tar.gz linux x64 infc \
            artifacts/infc-linux-x64/infc-linux-x64.tar.gz.sha256 \
            artifacts/infc-linux-x64/infc-linux-x64.tar.gz

          add_file infs-linux-x64.tar.gz linux x64 infs \
            artifacts/infs-linux-x64/infs-linux-x64.tar.gz.sha256 \
            artifacts/infs-linux-x64/infs-linux-x64.tar.gz

          add_file infc-windows-x64.zip windows x64 infc \
            artifacts/infc-windows-x64/infc-windows-x64.zip.sha256 \
            artifacts/infc-windows-x64/infc-windows-x64.zip

          add_file infs-windows-x64.zip windows x64 infs \
            artifacts/infs-windows-x64/infs-windows-x64.zip.sha256 \
            artifacts/infs-windows-x64/infs-windows-x64.zip

          add_file infc-macos-apple-silicon.tar.gz macos arm64 infc \
            artifacts/infc-macos-apple-silicon/infc-macos-apple-silicon.tar.gz.sha256 \
            artifacts/infc-macos-apple-silicon/infc-macos-apple-silicon.tar.gz

          add_file infs-macos-apple-silicon.tar.gz macos arm64 infs \
            artifacts/infs-macos-apple-silicon/infs-macos-apple-silicon.tar.gz.sha256 \
            artifacts/infs-macos-apple-silicon/infs-macos-apple-silicon.tar.gz

          # Wrap in version object (like Go's format)
          jq --arg v "$VERSION" '{version:$v,stable:true,files:.}' manifest.json > tmp.json
          echo "[$(<tmp.json)]" | jq . > manifest.json

          echo "Generated manifest.json:"
          cat manifest.json

      - name: Upload manifest to Release
        uses: softprops/action-gh-release@v1
        with:
          files: manifest.json
